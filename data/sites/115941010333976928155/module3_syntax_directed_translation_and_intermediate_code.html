
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>module3_syntax_directed_translation_and_intermediate_code</title>
<style>body{font-family:sans-serif;max-width:800px;margin:0 auto;padding:20px;line-height:1.6}img{max-width:100%}</style>
</head>
<body>
<h1 id="compiler-design-module-iii---syntax-directed-translation--intermediate-code-generation">Compiler Design: Module III - Syntax Directed Translation &amp; Intermediate Code Generation</h1>
<p>This guide covers the bridge between understanding code structure and generating machine-readable code. We'll explore how compilers extract meaning from program structure and translate it into an intermediate form that can be optimized and converted to machine code.</p>
<h2 id="-navigation">ðŸ“š Navigation</h2>
<ul>
<li><a href="#compiler-design-module-iii---syntax-directed-translation--intermediate-code-generation">Compiler Design: Module III - Syntax Directed Translation &amp; Intermediate Code Generation</a>
<ul>
<li><a href="#-navigation">ðŸ“š Navigation</a></li>
<li><a href="#1-syntax-directed-translation-sdt">1. Syntax-Directed Translation (SDT)</a></li>
<li><a href="#1-syntax-directed-translation-sdt-1">1. Syntax-Directed Translation (SDT)</a>
<ul>
<li><a href="#11-what-is-syntax-directed-translation">1.1 What is Syntax-Directed Translation?</a></li>
<li><a href="#12-attributes-synthesized-vs-inherited">1.2 Attributes: Synthesized vs. Inherited</a>
<ul>
<li><a href="#121-synthesized-attributes">1.2.1 Synthesized Attributes</a></li>
<li><a href="#122-inherited-attributes">1.2.2 Inherited Attributes</a></li>
</ul>
</li>
<li><a href="#13-construction-of-syntax-trees">1.3 Construction of Syntax Trees</a>
<ul>
<li><a href="#131-parse-tree-vs-abstract-syntax-tree-ast">1.3.1 Parse Tree vs. Abstract Syntax Tree (AST)</a></li>
<li><a href="#132-building-asts-with-sdt">1.3.2 Building ASTs with SDT</a></li>
</ul>
</li>
<li><a href="#14-s-attributed-vs-l-attributed-definitions">1.4 S-Attributed vs. L-Attributed Definitions</a>
<ul>
<li><a href="#141-s-attributed-definitions">1.4.1 S-Attributed Definitions</a></li>
<li><a href="#142-l-attributed-definitions">1.4.2 L-Attributed Definitions</a></li>
</ul>
</li>
<li><a href="#15-bottom-up-evaluation-of-s-attributed-definitions">1.5 Bottom-Up Evaluation of S-Attributed Definitions</a>
<ul>
<li><a href="#151-integration-with-lr-parsing">1.5.1 Integration with LR Parsing</a></li>
<li><a href="#152-implementation-with-yaccbison">1.5.2 Implementation with Yacc/Bison</a></li>
</ul>
</li>
<li><a href="#16-bottom-up-evaluation-of-l-attributed-definitions">1.6 Bottom-Up Evaluation of L-Attributed Definitions</a>
<ul>
<li><a href="#161-challenges-with-bottom-up-evaluation">1.6.1 Challenges with Bottom-Up Evaluation</a></li>
<li><a href="#162-solution-techniques">1.6.2 Solution Techniques</a></li>
</ul>
</li>
<li><a href="#17-top-down-translation">1.7 Top-Down Translation</a>
<ul>
<li><a href="#171-natural-fit-with-l-attributed-definitions">1.7.1 Natural Fit with L-Attributed Definitions</a></li>
<li><a href="#172-implementation-with-recursive-descent">1.7.2 Implementation with Recursive Descent</a></li>
<li><a href="#173-advantages-of-top-down-translation">1.7.3 Advantages of Top-Down Translation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-intermediate-code-generation">2. Intermediate Code Generation</a>
<ul>
<li><a href="#21-why-intermediate-code">2.1 Why Intermediate Code?</a>
<ul>
<li><a href="#211-the-problem-with-direct-translation">2.1.1 The Problem with Direct Translation</a></li>
<li><a href="#212-benefits-of-intermediate-code">2.1.2 Benefits of Intermediate Code</a></li>
</ul>
</li>
<li><a href="#22-intermediate-code-classification-and-representation">2.2 Intermediate Code Classification and Representation</a>
<ul>
<li><a href="#221-types-of-intermediate-representations">2.2.1 Types of Intermediate Representations</a></li>
<li><a href="#222-three-address-code-tac">2.2.2 Three-Address Code (TAC)</a></li>
<li><a href="#223-representations-of-three-address-code">2.2.3 Representations of Three-Address Code</a></li>
</ul>
</li>
<li><a href="#23-translation-of-assignment-statements">2.3 Translation of Assignment Statements</a>
<ul>
<li><a href="#231-simple-assignment-expressions">2.3.1 Simple Assignment Expressions</a></li>
<li><a href="#232-array-references">2.3.2 Array References</a></li>
</ul>
</li>
<li><a href="#24-translation-of-boolean-expressions">2.4 Translation of Boolean Expressions</a>
<ul>
<li><a href="#241-two-approaches-to-boolean-expression-translation">2.4.1 Two Approaches to Boolean Expression Translation</a></li>
<li><a href="#242-short-circuit-evaluation">2.4.2 Short-Circuit Evaluation</a></li>
</ul>
</li>
<li><a href="#25-translation-of-control-statements">2.5 Translation of Control Statements</a>
<ul>
<li><a href="#251-if-then-else-statements">2.5.1 If-Then-Else Statements</a></li>
<li><a href="#252-while-loops">2.5.2 While Loops</a></li>
</ul>
</li>
<li><a href="#26-back-patching">2.6 Back Patching</a>
<ul>
<li><a href="#261-the-forward-reference-problem">2.6.1 The Forward Reference Problem</a></li>
<li><a href="#262-back-patching-solution">2.6.2 Back Patching Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-type-checking">3. Type Checking</a>
<ul>
<li><a href="#31-specification-of-a-simple-type-checker">3.1 Specification of a Simple Type Checker</a>
<ul>
<li><a href="#311-type-system-components">3.1.1 Type System Components</a></li>
<li><a href="#312-type-checking-rules">3.1.2 Type Checking Rules</a></li>
<li><a href="#313-implementation-with-symbol-tables">3.1.3 Implementation with Symbol Tables</a></li>
</ul>
</li>
<li><a href="#32-equivalence-of-type-expressions">3.2 Equivalence of Type Expressions</a>
<ul>
<li><a href="#321-structural-equivalence">3.2.1 Structural Equivalence</a></li>
<li><a href="#322-name-equivalence">3.2.2 Name Equivalence</a></li>
<li><a href="#323-practical-considerations">3.2.3 Practical Considerations</a></li>
</ul>
</li>
<li><a href="#33-type-conversions">3.3 Type Conversions</a>
<ul>
<li><a href="#331-implicit-conversions-coercion">3.3.1 Implicit Conversions (Coercion)</a></li>
<li><a href="#332-explicit-conversions-casting">3.3.2 Explicit Conversions (Casting)</a></li>
<li><a href="#333-type-conversion-in-function-calls">3.3.3 Type Conversion in Function Calls</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary-and-key-takeaways">Summary and Key Takeaways</a>
<ul>
<li><a href="#syntax-directed-translation">Syntax-Directed Translation</a></li>
<li><a href="#intermediate-code-generation">Intermediate Code Generation</a></li>
<li><a href="#type-checking">Type Checking</a></li>
<li><a href="#exam-preparation-tips">Exam Preparation Tips</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="1-syntax-directed-translation-sdt">1. Syntax-Directed Translation (SDT)</h2>
<hr />
<h2 id="1-syntax-directed-translation-sdt-1">1. Syntax-Directed Translation (SDT)</h2>
<h3 id="11-what-is-syntax-directed-translation">1.1 What is Syntax-Directed Translation?</h3>
<p>Imagine you're reading a sentence in English: &quot;The cat sits on the mat.&quot; You recognize the grammatical structure (subject-verb-object), but you also understand the meaning - a specific feline is positioned on a specific floor covering.</p>
<p>In compilers, <strong>Syntax-Directed Translation (SDT)</strong> is the process of attaching semantic actions to grammatical productions. While the parser recognizes the structure (syntax), these actions compute and propagate the meaning (semantics).</p>
<p><strong>Formal Definition</strong>: A <strong>Syntax-Directed Definition (SDD)</strong> is a context-free grammar with semantic rules attached to each production. These rules define how to compute attribute values for the grammar symbols.</p>
<p><strong>Example</strong>: Consider the arithmetic expression <code>3 + 5</code></p>
<ul>
<li>Grammar rule: <code>E â†’ E1 + T</code></li>
<li>Semantic rule: <code>E.value = E1.value + T.value</code></li>
</ul>
<p>The semantic rule tells us: &quot;The value of this expression is the sum of the values of its sub-expressions.&quot;</p>
<h3 id="12-attributes-synthesized-vs-inherited">1.2 Attributes: Synthesized vs. Inherited</h3>
<p>Attributes are properties associated with grammar symbols that carry semantic information. There are two fundamental types:</p>
<h4 id="121-synthesized-attributes">1.2.1 Synthesized Attributes</h4>
<p><strong>Definition</strong>: A synthesized attribute at a node in a parse tree is computed from the attributes of its children.</p>
<p><strong>Flow Direction</strong>: Bottom-up (from leaves to root)</p>
<p><strong>Key Properties</strong>:</p>
<ul>
<li>Information flows upward in the parse tree</li>
<li>Can be evaluated during a bottom-up parse</li>
<li>Each production rule defines how to compute parent attributes from child attributes</li>
</ul>
<p><strong>Example</strong>: Expression Evaluation</p>
<p>Consider the grammar for arithmetic expressions:</p>
<pre><code>E â†’ E1 + T
E â†’ T
T â†’ num
</code></pre>
<p>With semantic rules:</p>
<pre><code>E â†’ E1 + T    { E.value = E1.value + T.value }
E â†’ T         { E.value = T.value }
T â†’ num       { T.value = num.lexval }
</code></pre>
<p>For the expression <code>3 + 5</code>:</p>
<ol>
<li>The <code>num</code> token for <code>3</code> has <code>lexval = 3</code></li>
<li>The <code>T</code> node synthesizes <code>T.value = 3</code></li>
<li>The <code>num</code> token for <code>5</code> has <code>lexval = 5</code></li>
<li>The <code>T</code> node synthesizes <code>T.value = 5</code></li>
<li>The <code>E</code> node for <code>3 + 5</code> synthesizes <code>E.value = 3 + 5 = 8</code></li>
</ol>
<h4 id="122-inherited-attributes">1.2.2 Inherited Attributes</h4>
<p><strong>Definition</strong>: An inherited attribute at a node is computed from the attributes of its parent or siblings.</p>
<p><strong>Flow Direction</strong>: Top-down or sideways (from parent to children or between siblings)</p>
<p><strong>Key Properties</strong>:</p>
<ul>
<li>Information flows downward or horizontally in the parse tree</li>
<li>Essential for context-dependent information</li>
<li>Often used for type propagation, scope information, etc.</li>
</ul>
<p><strong>Example</strong>: Variable Declaration Type Propagation</p>
<p>Consider declarations like <code>int a, b, c;</code></p>
<p>Grammar:</p>
<pre><code>D â†’ T L
T â†’ int
T â†’ float
L â†’ L1, id
L â†’ id
</code></pre>
<p>With semantic rules:</p>
<pre><code>D â†’ T L        { L.type = T.type }
T â†’ int        { T.type = integer }
T â†’ float      { T.type = float }
L â†’ L1, id     { L1.type = L.type; add_type(id.name, L.type) }
L â†’ id         { add_type(id.name, L.type) }
</code></pre>
<p>For <code>int a, b, c;</code>:</p>
<ol>
<li><code>T</code> synthesizes <code>T.type = integer</code></li>
<li><code>D</code> passes this to <code>L</code> as an inherited attribute: <code>L.type = integer</code></li>
<li><code>L</code> passes the type to its children, ensuring all variables are marked as <code>integer</code></li>
</ol>
<h3 id="13-construction-of-syntax-trees">1.3 Construction of Syntax Trees</h3>
<h4 id="131-parse-tree-vs-abstract-syntax-tree-ast">1.3.1 Parse Tree vs. Abstract Syntax Tree (AST)</h4>
<p><strong>Parse Tree (Concrete Syntax Tree)</strong>:</p>
<ul>
<li>
<p>Complete representation of the derivation</p>
</li>
<li>
<p>Includes every grammar rule used</p>
</li>
<li>
<p>Contains all punctuation, parentheses, etc.</p>
</li>
<li>
<p>Example for <code>a + b * c</code>:</p>
<pre><code>      E
     /|\
    E + T
    |   /|\
    T  T * F
    |  |  |
    F  F  id
    |  |
   id id
</code></pre>
</li>
</ul>
<p><strong>Abstract Syntax Tree (AST)</strong>:</p>
<ul>
<li>
<p>Compact representation of essential structure</p>
</li>
<li>
<p>Omits syntactic details</p>
</li>
<li>
<p>Operators become internal nodes, operands become leaves</p>
</li>
<li>
<p>Example for <code>a + b * c</code>:</p>
<pre><code>      +
     / \
    a   *
       / \
      b   c
</code></pre>
</li>
</ul>
<h4 id="132-building-asts-with-sdt">1.3.2 Building ASTs with SDT</h4>
<p>We can construct ASTs using synthesized attributes with node pointers:</p>
<p><strong>Node Creation Functions</strong>:</p>
<ul>
<li><code>mkOpNode(op, left, right)</code>: Creates operator node</li>
<li><code>mkLeafNode(type, value)</code>: Creates leaf node</li>
</ul>
<p><strong>Grammar with AST Construction</strong>:</p>
<pre><code>E â†’ E1 + T     { E.node = mkOpNode('+', E1.node, T.node) }
E â†’ E1 - T     { E.node = mkOpNode('-', E1.node, T.node) }
E â†’ T          { E.node = T.node }
T â†’ T1 * F     { T.node = mkOpNode('*', T1.node, F.node) }
T â†’ T1 / F     { T.node = mkOpNode('/', T1.node, F.node) }
T â†’ F          { T.node = F.node }
F â†’ ( E )      { F.node = E.node }
F â†’ id         { F.node = mkLeafNode(ID, id.name) }
F â†’ num        { F.node = mkLeafNode(NUM, num.value) }
</code></pre>
<p><strong>Example</strong>: Building AST for <code>a + b * c</code>:</p>
<ol>
<li><code>id(a)</code> â†’ leaf node for <code>a</code></li>
<li><code>id(b)</code> â†’ leaf node for <code>b</code></li>
<li><code>id(c)</code> â†’ leaf node for <code>c</code></li>
<li><code>b * c</code> â†’ operator node with children <code>b</code> and <code>c</code></li>
<li><code>a + (b * c)</code> â†’ operator node with children <code>a</code> and <code>*</code> node</li>
</ol>
<h3 id="14-s-attributed-vs-l-attributed-definitions">1.4 S-Attributed vs. L-Attributed Definitions</h3>
<h4 id="141-s-attributed-definitions">1.4.1 S-Attributed Definitions</h4>
<p><strong>Definition</strong>: An S-Attributed Definition is an SDD where all attributes are synthesized.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Only synthesized attributes</li>
<li>Can be evaluated in a single bottom-up pass</li>
<li>Compatible with LR parsers (bottom-up)</li>
<li>Simpler to implement</li>
</ul>
<p><strong>Example</strong>: Expression evaluation (from section 1.2.1) is S-attributed.</p>
<p><strong>Evaluation Process</strong>:</p>
<ol>
<li>Parse bottom-up</li>
<li>When reducing by a production, compute the synthesized attribute</li>
<li>The computed value is available for parent productions</li>
</ol>
<h4 id="142-l-attributed-definitions">1.4.2 L-Attributed Definitions</h4>
<p><strong>Definition</strong>: An L-Attributed Definition is an SDD where each inherited attribute of node X depends only on:</p>
<ol>
<li>Inherited attributes of X's parent</li>
<li>Synthesized attributes of X's left siblings</li>
<li>Inherited attributes of X's left siblings</li>
</ol>
<p><strong>Properties</strong>:</p>
<ul>
<li>Both synthesized and inherited attributes</li>
<li>Can be evaluated in a single left-to-right pass</li>
<li>Compatible with LL parsers (top-down)</li>
<li>More powerful than S-attributed definitions</li>
</ul>
<p><strong>Key Insight</strong>: The &quot;L&quot; stands for &quot;Left-to-right&quot; - we can evaluate attributes while traversing the parse tree from left to right.</p>
<p><strong>Example</strong>: Variable declaration with type propagation (from section 1.2.2) is L-attributed.</p>
<p><strong>Important Note</strong>: All S-attributed definitions are L-attributed, but not all L-attributed definitions are S-attributed.</p>
<h3 id="15-bottom-up-evaluation-of-s-attributed-definitions">1.5 Bottom-Up Evaluation of S-Attributed Definitions</h3>
<h4 id="151-integration-with-lr-parsing">1.5.1 Integration with LR Parsing</h4>
<p>LR parsers naturally support S-attributed definitions because:</p>
<ol>
<li>The parser builds the parse tree bottom-up</li>
<li>When a production is reduced, all child attributes are available</li>
<li>The semantic action can compute the parent's synthesized attribute</li>
</ol>
<h4 id="152-implementation-with-yaccbison">1.5.2 Implementation with Yacc/Bison</h4>
<p>In parser generators like Yacc, semantic actions are embedded in grammar rules:</p>
<pre><code class="language-yacc">%union {
    int value;
    char* name;
}

%token &lt;name&gt; ID
%token &lt;value&gt; NUMBER

%type &lt;value&gt; expr term factor

%%
expr: expr '+' term   { $$ = $1 + $3; }
    | term            { $$ = $1; }
    ;

term: term '*' factor { $$ = $1 * $3; }
    | factor          { $$ = $1; }
    ;

factor: '(' expr ')'  { $$ = $2; }
      | NUMBER        { $$ = $1; }
      ;
%%
</code></pre>
<p>Here, <code>$$</code> represents the synthesized attribute of the left-hand side non-terminal, and <code>$1</code>, <code>$2</code>, <code>$3</code> represent attributes of the right-hand side symbols.</p>
<h3 id="16-bottom-up-evaluation-of-l-attributed-definitions">1.6 Bottom-Up Evaluation of L-Attributed Definitions</h3>
<h4 id="161-challenges-with-bottom-up-evaluation">1.6.1 Challenges with Bottom-Up Evaluation</h4>
<p>L-attributed definitions are naturally suited for top-down parsing. Bottom-up evaluation requires additional techniques because:</p>
<ol>
<li>Inherited attributes need parent information</li>
<li>Bottom-up parsers don't have parent context during reduction</li>
</ol>
<h4 id="162-solution-techniques">1.6.2 Solution Techniques</h4>
<p><strong>1. Marker Non-terminals</strong>:</p>
<ul>
<li>Insert special markers in the grammar</li>
<li>Use them to pass inherited attributes</li>
</ul>
<p><strong>2. Embedded Actions</strong>:</p>
<ul>
<li>Place semantic actions in the middle of productions</li>
<li>Execute when the parser reaches that point</li>
</ul>
<p><strong>3. Multiple Passes</strong>:</p>
<ul>
<li>First pass: compute inherited attributes</li>
<li>Second pass: compute synthesized attributes</li>
</ul>
<p><strong>Example</strong>: Using embedded actions for type propagation:</p>
<pre><code class="language-yacc">declaration: type { current_type = $1; } identifier_list
           ;

type: INT    { $$ = INTEGER_TYPE; }
    | FLOAT  { $$ = FLOAT_TYPE; }
    ;

identifier_list: identifier_list ',' ID 
                 { add_symbol($3.name, current_type); }
               | ID 
                 { add_symbol($1.name, current_type); }
               ;
</code></pre>
<h3 id="17-top-down-translation">1.7 Top-Down Translation</h3>
<h4 id="171-natural-fit-with-l-attributed-definitions">1.7.1 Natural Fit with L-Attributed Definitions</h4>
<p>Top-down parsing naturally supports L-attributed definitions because:</p>
<ol>
<li>The parser processes nodes from parent to children</li>
<li>Inherited attributes can be passed as parameters</li>
<li>Synthesized attributes can be returned as function values</li>
</ol>
<h4 id="172-implementation-with-recursive-descent">1.7.2 Implementation with Recursive Descent</h4>
<p>In recursive descent parsers, each non-terminal becomes a function:</p>
<pre><code class="language-c">// Global symbol table
SymbolTable* sym_table;

// Function for expressions
ASTNode* parse_expr(Type inherited_type) {
    ASTNode* left = parse_term(inherited_type);
    
    while (current_token == '+' || current_token == '-') {
        Op op = current_token;
        advance_token();
        ASTNode* right = parse_term(inherited_type);
        left = mkOpNode(op, left, right);
    }
    
    return left;  // Synthesized attribute
}

// Function for declarations
void parse_declaration() {
    Type type = parse_type();  // Synthesized from type
    parse_identifier_list(type);  // Pass type as inherited
}
</code></pre>
<h4 id="173-advantages-of-top-down-translation">1.7.3 Advantages of Top-Down Translation</h4>
<ol>
<li><strong>Natural</strong>: Inherited attributes flow naturally with function parameters</li>
<li><strong>Flexible</strong>: Easy to implement complex semantic rules</li>
<li><strong>Readable</strong>: Code structure mirrors grammar structure</li>
<li><strong>Debuggable</strong>: Easier to trace attribute flow</li>
</ol>
<hr />
<h2 id="2-intermediate-code-generation">2. Intermediate Code Generation</h2>
<h3 id="21-why-intermediate-code">2.1 Why Intermediate Code?</h3>
<h4 id="211-the-problem-with-direct-translation">2.1.1 The Problem with Direct Translation</h4>
<p>Why not translate directly from source code to machine code?</p>
<ol>
<li><strong>Portability Issues</strong>: Different architectures (x86, ARM, MIPS) have different instruction sets</li>
<li><strong>Complexity</strong>: Managing optimization, register allocation, and code generation simultaneously is complex</li>
<li><strong>Maintenance</strong>: Changes require rewriting the entire compiler</li>
</ol>
<h4 id="212-benefits-of-intermediate-code">2.1.2 Benefits of Intermediate Code</h4>
<p><strong>Portability</strong>:</p>
<ul>
<li>Front-end: Source â†’ Intermediate (machine-independent)</li>
<li>Back-end: Intermediate â†’ Target (machine-specific)</li>
<li>One front-end can work with multiple back-ends</li>
</ul>
<p><strong>Optimization</strong>:</p>
<ul>
<li>Intermediate code is simpler and more uniform</li>
<li>Easier to apply optimization techniques</li>
<li>Optimizations can be machine-independent</li>
</ul>
<p><strong>Modularity</strong>:</p>
<ul>
<li>Clear separation of concerns</li>
<li>Easier to maintain and extend</li>
<li>Allows for different optimization levels</li>
</ul>
<h3 id="22-intermediate-code-classification-and-representation">2.2 Intermediate Code Classification and Representation</h3>
<h4 id="221-types-of-intermediate-representations">2.2.1 Types of Intermediate Representations</h4>
<p><strong>1. High-Level IR</strong>:</p>
<ul>
<li>Close to source language</li>
<li>Preserves structure like loops, conditions</li>
<li>Example: Three-address code with high-level operators</li>
</ul>
<p><strong>2. Medium-Level IR</strong>:</p>
<ul>
<li>Balance between high-level and low-level</li>
<li>More explicit about operations</li>
<li>Example: Static single assignment (SSA) form</li>
</ul>
<p><strong>3. Low-Level IR</strong>:</p>
<ul>
<li>Close to machine code</li>
<li>Explicit about registers, memory layout</li>
<li>Example: Register transfer language</li>
</ul>
<h4 id="222-three-address-code-tac">2.2.2 Three-Address Code (TAC)</h4>
<p><strong>Definition</strong>: Three-Address Code consists of statements with at most three operands: <code>result = operand1 operator operand2</code></p>
<p><strong>Properties</strong>:</p>
<ul>
<li>Each statement has at most one operator on the right side</li>
<li>No built-up expressions</li>
<li>Uses temporary variables for intermediate results</li>
</ul>
<p><strong>Example</strong>: <code>x = (a + b) * (c - d)</code> becomes:</p>
<pre><code>t1 = a + b
t2 = c - d
t3 = t1 * t2
x = t3
</code></pre>
<h4 id="223-representations-of-three-address-code">2.2.3 Representations of Three-Address Code</h4>
<p><strong>1. Quadruples</strong>:</p>
<p>Format: <code>(operator, arg1, arg2, result)</code></p>
<p>Example for <code>x = a + b * c</code>:</p>
<pre><code>(+, a, b, t1)
(*, t1, c, t2)
(=, t2, , x)
</code></pre>
<p><strong>2. Triples</strong>:</p>
<p>Format: <code>(operator, arg1, arg2)</code> where result is the position</p>
<p>Example for <code>x = a + b * c</code>:</p>
<pre><code>0: (+, a, b)     // result is position 0
1: (*, 0, c)     // result is position 1
2: (=, 1, x)     // assignment
</code></pre>
<p><strong>3. Indirect Triples</strong>:</p>
<p>Format: Use pointers to triples, allowing reordering</p>
<p>Example:</p>
<pre><code>Instruction List: [100, 101, 102]
Triples:
100: (+, a, b)
101: (*, 100, c)
102: (=, 101, x)
</code></pre>
<h3 id="23-translation-of-assignment-statements">2.3 Translation of Assignment Statements</h3>
<h4 id="231-simple-assignment-expressions">2.3.1 Simple Assignment Expressions</h4>
<p><strong>SDT for Expression Translation</strong>:</p>
<p>Grammar with semantic actions:</p>
<pre><code>E â†’ E1 + T    { E.place = new_temp(); emit(E.place, '=', E1.place, '+', T.place) }
E â†’ E1 - T    { E.place = new_temp(); emit(E.place, '=', E1.place, '-', T.place) }
E â†’ T         { E.place = T.place }
T â†’ T1 * F    { T.place = new_temp(); emit(T.place, '=', T1.place, '*', F.place) }
T â†’ T1 / F    { T.place = new_temp(); emit(T.place, '=', T1.place, '/', F.place) }
T â†’ F         { T.place = F.place }
F â†’ ( E )     { F.place = E.place }
F â†’ id        { F.place = id.name }
F â†’ num       { F.place = num.value }
</code></pre>
<p><strong>Example</strong>: Translating <code>x = a + b * c</code></p>
<ol>
<li><code>F â†’ id(a)</code> â†’ <code>F.place = &quot;a&quot;</code></li>
<li><code>F â†’ id(b)</code> â†’ <code>F.place = &quot;b&quot;</code></li>
<li><code>T â†’ F * F</code> â†’ <code>T.place = new_temp()</code> â†’ emit <code>t1 = b * c</code></li>
<li><code>E â†’ E + T</code> â†’ <code>E.place = new_temp()</code> â†’ emit <code>t2 = a + t1</code></li>
<li>Assignment: emit <code>x = t2</code></li>
</ol>
<h4 id="232-array-references">2.3.2 Array References</h4>
<p><strong>Grammar for Array Elements</strong>:</p>
<pre><code>L â†’ id [ E ]     { L.place = new_temp(); emit(L.place, '=', id.base, '+', E.place * element_size) }
L â†’ id           { L.place = id.name }
</code></pre>
<p><strong>Example</strong>: <code>A[i] = A[j] + 1</code></p>
<p>Translation:</p>
<pre><code>t1 = j * 4        // Assuming 4 bytes per element
t2 = A[t1]        // A[j]
t3 = t2 + 1
t4 = i * 4
A[t4] = t3        // A[i] = ...
</code></pre>
<h3 id="24-translation-of-boolean-expressions">2.4 Translation of Boolean Expressions</h3>
<h4 id="241-two-approaches-to-boolean-expression-translation">2.4.1 Two Approaches to Boolean Expression Translation</h4>
<p><strong>1. Numerical Approach</strong>:</p>
<ul>
<li>Evaluate to 0 (false) or 1 (true)</li>
<li>Similar to arithmetic expressions</li>
</ul>
<p><strong>2. Flow of Control Approach</strong>:</p>
<ul>
<li>Generate jumps to true/false labels</li>
<li>More efficient for control statements</li>
</ul>
<h4 id="242-short-circuit-evaluation">2.4.2 Short-Circuit Evaluation</h4>
<p><strong>Concept</strong>: In expressions like <code>A || B</code>, if A is true, we don't need to evaluate B.</p>
<p><strong>Attributes for Boolean Expressions</strong>:</p>
<ul>
<li><code>E.true</code>: Label to jump to if expression is true</li>
<li><code>E.false</code>: Label to jump to if expression is false</li>
</ul>
<p><strong>SDT for Boolean Expressions</strong>:</p>
<pre><code>E â†’ E1 || E2    {
    E1.true = E.true;
    E1.false = new_label();
    E2.true = E.true;
    E2.false = E.false;
    emit(E1.false ':');
    generate_code(E2);
}

E â†’ E1 &amp;&amp; E2    {
    E1.true = new_label();
    E1.false = E.false;
    E2.true = E.true;
    E2.false = E.false;
    emit(E1.true ':');
    generate_code(E2);
}

E â†’ id1 relop id2  {
    emit('if', id1.name, relop.op, id2.name, 'goto', E.true);
    emit('goto', E.false);
}
</code></pre>
<p><strong>Example</strong>: <code>if (x &lt; 10 || y &gt; 20) S1; else S2;</code></p>
<p>Generated code:</p>
<pre><code>if x &lt; 10 goto L_true
goto L_test2
L_test2:
if y &gt; 20 goto L_true
goto L_false
L_true:
&lt;code for S1&gt;
goto L_next
L_false:
&lt;code for S2&gt;
L_next:
</code></pre>
<h3 id="25-translation-of-control-statements">2.5 Translation of Control Statements</h3>
<h4 id="251-if-then-else-statements">2.5.1 If-Then-Else Statements</h4>
<p><strong>Grammar</strong>:</p>
<pre><code>S â†’ if ( E ) S1 else S2
</code></pre>
<p><strong>Translation Strategy</strong>:</p>
<ol>
<li>Generate code for E to jump to true/false labels</li>
<li>Generate code for S1 at true label</li>
<li>Generate jump to end after S1</li>
<li>Generate code for S2 at false label</li>
</ol>
<p><strong>SDT</strong>:</p>
<pre><code>S â†’ if ( E ) S1 else S2    {
    E.true = new_label();
    E.false = new_label();
    S1.next = S.next;
    S2.next = S.next;
    S.after = new_label();
    
    generate_code(E);
    emit(E.true ':');
    generate_code(S1);
    emit('goto', S.after);
    emit(E.false ':');
    generate_code(S2);
    emit(S.after ':');
}
</code></pre>
<h4 id="252-while-loops">2.5.2 While Loops</h4>
<p><strong>Grammar</strong>:</p>
<pre><code>S â†’ while ( E ) S1
</code></pre>
<p><strong>Translation Strategy</strong>:</p>
<ol>
<li>Create label for loop start</li>
<li>Generate code for E with jumps to body/end</li>
<li>Generate code for S1 at true label</li>
<li>Jump back to loop start</li>
</ol>
<p><strong>SDT</strong>:</p>
<pre><code>S â†’ while ( E ) S1    {
    S.begin = new_label();
    E.true = new_label();
    E.false = S.next;
    S1.next = S.begin;
    
    emit(S.begin ':');
    generate_code(E);
    emit(E.true ':');
    generate_code(S1);
    emit('goto', S.begin);
}
</code></pre>
<p><strong>Example</strong>: <code>while (i &lt; 10) { i = i + 1; }</code></p>
<p>Generated code:</p>
<pre><code>L_begin:
if i &lt; 10 goto L_body
goto L_next
L_body:
t1 = i + 1
i = t1
goto L_begin
L_next:
</code></pre>
<h3 id="26-back-patching">2.6 Back Patching</h3>
<h4 id="261-the-forward-reference-problem">2.6.1 The Forward Reference Problem</h4>
<p><strong>Problem</strong>: When generating code for control statements, we often need to jump to labels that haven't been defined yet.</p>
<p><strong>Example</strong>: In <code>if (E) S1; else S2;</code>, when we generate the test for E, we don't know where S1 or S2 start.</p>
<h4 id="262-back-patching-solution">2.6.2 Back Patching Solution</h4>
<p><strong>Concept</strong>: Use placeholder labels and fix them later when the actual label is known.</p>
<p><strong>Data Structures</strong>:</p>
<ul>
<li>Lists to track jumps that need patching</li>
<li><code>true_list</code>: Jumps to true label</li>
<li><code>false_list</code>: Jumps to false label</li>
</ul>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>When generating a forward jump, use a placeholder</li>
<li>Add the instruction's address to a list</li>
<li>When the actual label is known, patch all instructions in the list</li>
</ol>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-c">typedef struct {
    int* instructions;
    int count;
    int capacity;
} InstrList;

InstrList* make_list(int instr) {
    InstrList* list = malloc(sizeof(InstrList));
    list-&gt;instructions = malloc(sizeof(int));
    list-&gt;instructions[0] = instr;
    list-&gt;count = 1;
    list-&gt;capacity = 1;
    return list;
}

InstrList* merge(InstrList* l1, InstrList* l2) {
    InstrList* result = malloc(sizeof(InstrList));
    result-&gt;count = l1-&gt;count + l2-&gt;count;
    result-&gt;capacity = result-&gt;count;
    result-&gt;instructions = malloc(result-&gt;capacity * sizeof(int));
    memcpy(result-&gt;instructions, l1-&gt;instructions, l1-&gt;count * sizeof(int));
    memcpy(result-&gt;instructions + l1-&gt;count, l2-&gt;instructions, l2-&gt;count * sizeof(int));
    return result;
}

void backpatch(InstrList* list, int label) {
    for (int i = 0; i &lt; list-&gt;count; i++) {
        int instr = list-&gt;instructions[i];
        patch_instruction(instr, label);
    }
}
</code></pre>
<p><strong>Example</strong>: Backpatching for <code>if (x &lt; 10 || y &gt; 20) S1; else S2;</code></p>
<ol>
<li>Generate <code>if x &lt; 10 goto ___</code> â†’ add to true_list</li>
<li>Generate <code>goto ___</code> â†’ add to false_list</li>
<li>Generate <code>if y &gt; 20 goto ___</code> â†’ add to true_list</li>
<li>Generate <code>goto ___</code> â†’ add to false_list</li>
<li>When we know where S1 starts (label L_true), backpatch true_list</li>
<li>When we know where S2 starts (label L_false), backpatch false_list</li>
</ol>
<hr />
<h2 id="3-type-checking">3. Type Checking</h2>
<h3 id="31-specification-of-a-simple-type-checker">3.1 Specification of a Simple Type Checker</h3>
<h4 id="311-type-system-components">3.1.1 Type System Components</h4>
<p><strong>1. Basic Types</strong>:</p>
<ul>
<li>Integer, Float, Boolean, Character, etc.</li>
</ul>
<p><strong>2. Type Constructors</strong>:</p>
<ul>
<li>Arrays: array(element_type, size)</li>
<li>Functions: function(parameter_types, return_type)</li>
<li>Pointers: pointer(base_type)</li>
</ul>
<p><strong>3. Type Expressions</strong>:</p>
<ul>
<li>Structural representation of types</li>
<li>Used for type checking and equivalence</li>
</ul>
<h4 id="312-type-checking-rules">3.1.2 Type Checking Rules</h4>
<p><strong>Expression Rules</strong>:</p>
<pre><code>type(E1 + E2) = 
    if type(E1) = integer and type(E2) = integer then integer
    else if type(E1) = float and type(E2) = float then float
    else if type(E1) = integer and type(E2) = float then float
    else if type(E1) = float and type(E2) = integer then float
    else type_error
</code></pre>
<p><strong>Assignment Rules</strong>:</p>
<pre><code>valid_assignment(type1, type2) = 
    if type1 = type2 then true
    else if type1 = float and type2 = integer then true  // with conversion
    else false
</code></pre>
<p><strong>Function Call Rules</strong>:</p>
<pre><code>valid_call(function_type, argument_types) =
    if function_type.parameter_types = argument_types then true
    else false
</code></pre>
<h4 id="313-implementation-with-symbol-tables">3.1.3 Implementation with Symbol Tables</h4>
<p><strong>Symbol Table Structure</strong>:</p>
<pre><code class="language-c">typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_BOOL,
    TYPE_ARRAY,
    TYPE_FUNCTION,
    TYPE_POINTER
} TypeKind;

typedef struct Type {
    TypeKind kind;
    union {
        struct { struct Type* element_type; int size; } array;
        struct { struct Type** param_types; struct Type* return_type; int param_count; } function;
        struct Type* base_type;  // for pointers
    } info;
} Type;

typedef struct Symbol {
    char* name;
    Type* type;
    int scope_level;
    struct Symbol* next;
} Symbol;
</code></pre>
<p><strong>Type Checking Function</strong>:</p>
<pre><code class="language-c">Type* check_expression(ASTNode* node) {
    switch (node-&gt;type) {
        case NODE_BINARY_OP:
            Type* left_type = check_expression(node-&gt;left);
            Type* right_type = check_expression(node-&gt;right);
            return check_binary_op(node-&gt;op, left_type, right_type);
        
        case NODE_IDENTIFIER:
            Symbol* sym = lookup_symbol(node-&gt;name);
            if (!sym) report_error(&quot;Undefined variable&quot;);
            return sym-&gt;type;
        
        case NODE_LITERAL:
            return get_literal_type(node-&gt;value);
    }
}
</code></pre>
<h3 id="32-equivalence-of-type-expressions">3.2 Equivalence of Type Expressions</h3>
<h4 id="321-structural-equivalence">3.2.1 Structural Equivalence</h4>
<p><strong>Definition</strong>: Two types are structurally equivalent if they have the same structure, regardless of their names.</p>
<p><strong>Algorithm</strong>:</p>
<pre><code class="language-c">bool structurally_equivalent(Type* t1, Type* t2) {
    if (t1-&gt;kind != t2-&gt;kind) return false;
    
    switch (t1-&gt;kind) {
        case TYPE_INT:
        case TYPE_FLOAT:
        case TYPE_BOOL:
            return true;
        
        case TYPE_ARRAY:
            return structurally_equivalent(t1-&gt;info.array.element_type, 
                                         t2-&gt;info.array.element_type) &amp;&amp;
                   t1-&gt;info.array.size == t2-&gt;info.array.size;
        
        case TYPE_FUNCTION:
            if (t1-&gt;info.function.param_count != t2-&gt;info.function.param_count)
                return false;
            for (int i = 0; i &lt; t1-&gt;info.function.param_count; i++) {
                if (!structurally_equivalent(t1-&gt;info.function.param_types[i],
                                           t2-&gt;info.function.param_types[i]))
                    return false;
            }
            return structurally_equivalent(t1-&gt;info.function.return_type,
                                         t2-&gt;info.function.return_type);
    }
}
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-c">struct {
    int x;
    float y;
} a;

struct {
    int x;
    float y;
} b;
</code></pre>
<p>Under structural equivalence, <code>a</code> and <code>b</code> have the same type.</p>
<h4 id="322-name-equivalence">3.2.2 Name Equivalence</h4>
<p><strong>Definition</strong>: Two types are name equivalent only if they have the same name.</p>
<p><strong>Algorithm</strong>:</p>
<pre><code class="language-c">bool name_equivalent(Type* t1, Type* t2) {
    return t1 == t2;  // Simple pointer comparison
}
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-c">typedef struct {
    int x;
    float y;
} Point;

typedef struct {
    int x;
    float y;
} Vector;

Point p;
Vector v;
</code></pre>
<p>Under name equivalence, <code>Point</code> and <code>Vector</code> are different types.</p>
<h4 id="323-practical-considerations">3.2.3 Practical Considerations</h4>
<p><strong>Most Languages Use Mixed Approach</strong>:</p>
<ul>
<li>Basic types: name equivalence</li>
<li>User-defined types: name equivalence</li>
<li>Anonymous types: structural equivalence</li>
</ul>
<p><strong>Example in C</strong>:</p>
<pre><code class="language-c">typedef int* IntPtr;
int* p1;
IntPtr p2;

// p1 and p2 are compatible (name equivalence for typedef)
// But:
struct { int x; } a;
struct { int x; } b;

// a and b are different (name equivalence for structs)
</code></pre>
<h3 id="33-type-conversions">3.3 Type Conversions</h3>
<h4 id="331-implicit-conversions-coercion">3.3.1 Implicit Conversions (Coercion)</h4>
<p><strong>Definition</strong>: Automatic conversion between compatible types performed by the compiler.</p>
<p><strong>Common Coercion Rules</strong>:</p>
<ol>
<li>
<p><strong>Widening</strong>: Convert to a type that can represent all values of the original</p>
<ul>
<li><code>int</code> â†’ <code>float</code></li>
<li><code>float</code> â†’ <code>double</code></li>
<li><code>char</code> â†’ <code>int</code></li>
</ul>
</li>
<li>
<p><strong>Narrowing</strong>: Convert to a type with less precision (usually warning)</p>
<ul>
<li><code>float</code> â†’ <code>int</code></li>
<li><code>int</code> â†’ <code>char</code></li>
</ul>
</li>
</ol>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-c">Type* common_type(Type* t1, Type* t2) {
    if (equivalent(t1, t2)) return t1;
    
    // Integer promotion
    if (t1-&gt;kind == TYPE_INT &amp;&amp; t2-&gt;kind == TYPE_FLOAT) return t2;
    if (t1-&gt;kind == TYPE_FLOAT &amp;&amp; t2-&gt;kind == TYPE_INT) return t1;
    
    // Array to pointer decay
    if (t1-&gt;kind == TYPE_ARRAY &amp;&amp; t2-&gt;kind == TYPE_POINTER &amp;&amp;
        equivalent(t1-&gt;info.array.element_type, t2-&gt;info.base_type))
        return t2;
    
    return NULL;  // No implicit conversion
}
</code></pre>
<p><strong>Code Generation for Coercion</strong>:</p>
<pre><code class="language-c">void generate_coercion(Type* from, Type* to, char* from_var, char* to_var) {
    if (from-&gt;kind == TYPE_INT &amp;&amp; to-&gt;kind == TYPE_FLOAT) {
        emit(&quot;%s = int_to_float(%s)&quot;, to_var, from_var);
    } else if (from-&gt;kind == TYPE_FLOAT &amp;&amp; to-&gt;kind == TYPE_INT) {
        emit(&quot;%s = float_to_int(%s)&quot;, to_var, from_var);
    }
}
</code></pre>
<h4 id="332-explicit-conversions-casting">3.3.2 Explicit Conversions (Casting)</h4>
<p><strong>Definition</strong>: Programmer-specified type conversion using cast operators.</p>
<p><strong>Syntax</strong>:</p>
<ul>
<li>C-style: <code>(type)expression</code></li>
<li>C++ style: <code>static_cast&lt;type&gt;(expression)</code>, <code>reinterpret_cast&lt;type&gt;(expression)</code></li>
</ul>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-c">void handle_cast(Type* target_type, ASTNode* expression) {
    Type* expr_type = check_expression(expression);
    
    if (!valid_cast(expr_type, target_type)) {
        report_error(&quot;Invalid cast&quot;);
        return;
    }
    
    char* temp = generate_expression_code(expression);
    generate_coercion(expr_type, target_type, temp, new_temp());
}
</code></pre>
<p><strong>Type Safety Considerations</strong>:</p>
<ol>
<li><strong>Safe Casts</strong>: Between related types (e.g., <code>int</code> â†’ <code>float</code>)</li>
<li><strong>Unsafe Casts</strong>: Between unrelated types (e.g., pointer to integer)</li>
<li><strong>Implementation-defined</strong>: Bit reinterpretation</li>
</ol>
<h4 id="333-type-conversion-in-function-calls">3.3.3 Type Conversion in Function Calls</h4>
<p><strong>Argument Promotion</strong>:</p>
<ul>
<li><code>char</code> and <code>short</code> â†’ <code>int</code></li>
<li><code>float</code> â†’ <code>double</code> (in old C)</li>
</ul>
<p><strong>Parameter Matching</strong>:</p>
<pre><code class="language-c">void check_function_call(Symbol* function, ASTNode** arguments, int arg_count) {
    Type* func_type = function-&gt;type;
    
    if (func_type-&gt;info.function.param_count != arg_count) {
        report_error(&quot;Wrong number of arguments&quot;);
        return;
    }
    
    for (int i = 0; i &lt; arg_count; i++) {
        Type* arg_type = check_expression(arguments[i]);
        Type* param_type = func_type-&gt;info.function.param_types[i];
        
        if (!equivalent(arg_type, param_type)) {
            Type* common = common_type(arg_type, param_type);
            if (common) {
                generate_coercion(arg_type, param_type, 
                                 get_temp_name(i), get_temp_name(i));
            } else {
                report_error(&quot;Type mismatch in argument %d&quot;, i+1);
            }
        }
    }
}
</code></pre>
<hr />
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<h3 id="syntax-directed-translation">Syntax-Directed Translation</h3>
<ol>
<li><strong>SDDs</strong> attach semantic actions to grammar rules</li>
<li><strong>Synthesized attributes</strong> flow upward (children â†’ parent)</li>
<li><strong>Inherited attributes</strong> flow downward (parent â†’ children)</li>
<li><strong>S-attributed</strong> definitions use only synthesized attributes</li>
<li><strong>L-attributed</strong> definitions use both, with restrictions on dependencies</li>
<li><strong>Bottom-up evaluation</strong> works naturally with S-attributed definitions</li>
<li><strong>Top-down translation</strong> works naturally with L-attributed definitions</li>
</ol>
<h3 id="intermediate-code-generation">Intermediate Code Generation</h3>
<ol>
<li><strong>Three-address code</strong> is the most common IR form</li>
<li><strong>Quadruples, triples, and indirect triples</strong> are different representations</li>
<li><strong>Boolean expressions</strong> can be translated using numerical or control-flow approaches</li>
<li><strong>Short-circuit evaluation</strong> generates efficient code for logical operations</li>
<li><strong>Back patching</strong> solves the forward reference problem in control statements</li>
</ol>
<h3 id="type-checking">Type Checking</h3>
<ol>
<li><strong>Type systems</strong> define valid operations and conversions</li>
<li><strong>Structural equivalence</strong> compares type structures</li>
<li><strong>Name equivalence</strong> compares type names</li>
<li><strong>Implicit conversions</strong> (coercion) are automatic</li>
<li><strong>Explicit conversions</strong> (casts) are programmer-specified</li>
</ol>
<h3 id="exam-preparation-tips">Exam Preparation Tips</h3>
<ol>
<li><strong>Practice constructing ASTs</strong> from expressions</li>
<li><strong>Write semantic rules</strong> for simple grammars</li>
<li><strong>Generate three-address code</strong> for various statements</li>
<li><strong>Understand back patching</strong> with examples</li>
<li><strong>Compare type equivalence</strong> approaches with examples</li>
<li><strong>Study type conversion rules</strong> and their implementation</li>
</ol>
<p>This comprehensive guide covers all topics in Module III of your syllabus with detailed explanations suitable for someone without prior knowledge of compiler design. The examples and implementations provide practical understanding of the concepts.</p>

</body>
</html>
